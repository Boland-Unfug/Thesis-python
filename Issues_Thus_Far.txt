Goals for tomarrow:
set up base agent class X
set up tit for tat, evil, and good agents X

set up basic implementation for main class X
Add game class X
Add visualization
- I want it to show the strategy, each win, and update the score.
so far I show the strategy and update the score
I want to make the memory work for tit-for-tat, its due to it not remembering 'faces', but just having a general memory of neighbors
    add decorators
    add time checking
    add circles

Creating a hash system for memory, check notebook for more. X
The algorithm:
Hash table. I can abuse the fact that I only have 4 output states, and 4 combinations of inputs.
hash algorithm:
    factors: round, agent1, and agent2
    I dedicate 16 bits for round, and 8 each for agent 1 and agent 2, and then bitshift the round 16 to the left and agent 1 to the right, before merging the bitspaces together.
    I also cut memory in half by always having player 1 be the agent with the lower ID, meaning I can infer agent without needing iti stored.
    This has given some really nice results, with processing speeds for gameplay being fast enough to not bottleneck the system.


Time examples:

10x10 grid, 1,000 iterations

    Creating agents...
    Done. Time elapsed: 0.0 seconds.
    Creating world...
    Done. Time elapsed: 0.006682872772216797 seconds.
    Updating neighbors...
    Done. Time elapsed: 0.000997781753540039 seconds.
    Starting game...
    Done. Time elapsed: 0.0 seconds.
    Playing game...
    Done. Time elapsed: 7.4314587116241455 seconds.
    Each round took 0.007431458711624145 seconds.
    Printing scores in a grid for human readability...
    7000    13000   13000   9000    13000   6000    12000   12000   15000   9000
    17000   12000   12000   20000   24000   9000    32000   12000   15000   9000
    9000    18000   15000   12000   24000   9000    24000   24000   28000   21000
    9000    36000   18000   32000   12000   24000   6000    16000   6000    6000
    13000   12000   12000   15000   28000   15000   28000   28000   32000   12000
    17000   32000   18000   36000   15000   15000   12000   9000    12000   9000
    6000    15000   18000   21000   18000   40000   15000   32000   32000   12000
    25000   18000   21000   18000   18000   18000   12000   24000   9000    9000
    12000   18000   40000   18000   40000   21000   15000   28000   28000   12000
    9000    12000   12000   9000    12000   12000   9000    17000   6000    6000
    Done. Time elapsed: 0.007860898971557617 seconds.

consider modifying the agents so that you don't have to enter both the strategy and movement strategy manually,
since there could be a lot of overlap, where you apply many strategies to the same movement strategy (I can probably just use subclass)

MAJOR UPDATE:
Agents are no longer grid based, and are now circles that move around the screen.
Instead of having a grid, I now have a list of agents.
Instead of having neighbors, I now have them check for collisions with other agents, and then play the game with them.

I used a a temporary file (pycirlces) to learn about how to make circles move around the screen, and then I used that knowledge to make this.