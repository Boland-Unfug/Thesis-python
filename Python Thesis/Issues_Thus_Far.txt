Goals for tomarrow:
set up base agent class X
set up tit for tat, evil, and good agents X

set up basic implementation for main class X
Add game class X
Add visualization
- I want it to show the strategy, each win, and update the score.
so far I show the strategy and update the score
I want to make the memory work for tit-for-tat, its due to it not remembering 'faces', but just having a general memory of neighbors
    add decorators
    add time checking
    add circles

Creating a hash system for memory, check notebook for more. X
The algorithm:
Hash table. I can abuse the fact that I only have 4 output states, and 4 combinations of inputs.
hash algorithm:
    factors: round, agent1, and agent2
    I dedicate 16 bits for round, and 8 each for agent 1 and agent 2, and then bitshift the round 16 to the left and agent 1 to the right, before merging the bitspaces together.
    I also cut memory in half by always having player 1 be the agent with the lower ID, meaning I can infer agent without needing iti stored.
    This has given some really nice results, with processing speeds for gameplay being fast enough to not bottleneck the system.
make it so that you can play any game, or at least change the rules for scores

Time examples:

10x10 grid, 1,000 iterations

    Creating agents...
    Done. Time elapsed: 0.0 seconds.
    Creating world...
    Done. Time elapsed: 0.006682872772216797 seconds.
    Updating neighbors...
    Done. Time elapsed: 0.000997781753540039 seconds.
    Starting game...
    Done. Time elapsed: 0.0 seconds.
    Playing game...
    Done. Time elapsed: 7.4314587116241455 seconds.
    Each round took 0.007431458711624145 seconds.
    Printing scores in a grid for human readability...
    7000    13000   13000   9000    13000   6000    12000   12000   15000   9000
    17000   12000   12000   20000   24000   9000    32000   12000   15000   9000
    9000    18000   15000   12000   24000   9000    24000   24000   28000   21000
    9000    36000   18000   32000   12000   24000   6000    16000   6000    6000
    13000   12000   12000   15000   28000   15000   28000   28000   32000   12000
    17000   32000   18000   36000   15000   15000   12000   9000    12000   9000
    6000    15000   18000   21000   18000   40000   15000   32000   32000   12000
    25000   18000   21000   18000   18000   18000   12000   24000   9000    9000
    12000   18000   40000   18000   40000   21000   15000   28000   28000   12000
    9000    12000   12000   9000    12000   12000   9000    17000   6000    6000
    Done. Time elapsed: 0.007860898971557617 seconds.

consider modifying the agents so that you don't have to enter both the strategy and movement strategy manually,
since there could be a lot of overlap, where you apply many strategies to the same movement strategy (I can probably just use subclass)

MAJOR UPDATE:
Agents are no longer grid based, and are now circles that move around the screen.
Instead of having a grid, I now have a list of agents.
Instead of having neighbors, I now have them check for collisions with other agents, and then play the game with them.

I used a a temporary file (pycirlces) to learn about how to make circles move around the screen, and then I used that knowledge to make this.

new list of todos:
Standardize docstrings
Standardize & add comments
Add more strategies
Add more movement strategies
add drift X
add momentum
Improve collision
Add testability, through decorators for printing and time checking
Add file output
add data analysis
add downloadability/portability
add command line args


New New list of todos:
seems to not be updating the recent history
1. Add Movement strategies
 - Chaser, takes the acceleration of their last collision X
 - runner, takes the opposite of their last collision X
 - random X, set as default strategy
 - dodger, takes the opposite of their last collision, but randomizes one of the axis
 - straight, always moves in the line it was moving in, still bounces off walls
2. Add data analysis
 - Add data to a file X
 - create a program that can graph the data X
3. Add in default values and make everything variable.
 - use name = self.name to allow for default values, and modifying them
 - add a readme
4. Collision
 - start with grid based
 - add more from chatgpt if needed
 - add a little collision visual
 - prioritize quality
5. Move to another language
 - Ask about use of libraries
 - refer back to https://www.youtube.com/watch?v=lS_qeBy3aQI, pezzzas work
6. Hash function/ data structure
 - The current hash still works, however it can be made more space efficient
  - previous design: assigning bits for certain roles, specifically the round, agent1, and agent2. This made some blank space, but not much
  - maybe it can be improved?
7. Maybe machine learning?
8. Improve visual queues
 - for graphs, indicate strategy with color and movement strategy with line type
 - for simulation, indicate strategy with color and movement strategy with border?

 Reorganize TODOS, add them to the code directly

This code produces an interesting mechanic where they occasionally merge together and collide frequently, which could be an interesting thing to explore.
for agent in self.agents:
            for agent2 in self.agents:
                if agent != agent2:
                    if (agent.get_position()[0] - agent2.get_position()[0])**2 + (agent.get_position()[1] - agent2.get_position()[1])**2 <= (self.agents_size*2)**2:
                        agent.set_position(agent.get_position()[0] - agent.get_direction()[0], agent.get_position()[1] - agent.get_direction()[1])
                        # agent2.set_position(agent2.get_position()[0] - agent2.get_direction()[0], agent2.get_position()[1] - agent2.get_direction()[1])
                        self.game.play(agent, agent2)
                        agent.set_direction([agent.get_direction()[0] * -1, agent.get_direction()[1] * -1])
                        # agent2.set_direction([agent2.get_direction()[0] * -1, agent2.get_direction()[1] * -1])
            if agent.get_position()[0] - self.agents_size <= 0 or agent.get_position()[0] + self.agents_size >= self.world_size:
                agent.set_position(agent.get_position()[0] - agent.get_direction()[0], agent.get_position()[1])
                # agent.set_direction([agent.get_direction()[0] * -1, agent.get_direction()[1]])
            if agent.get_position()[1] - self.agents_size <= 0 or agent.get_position()[1] + self.agents_size >= self.world_size:
                agent.set_position(agent.get_position()[0], agent.get_position()[1] - agent.get_direction()[1])
                # agent.set_direction([agent.get_direction()[0], agent.get_direction()[1] * -1])


TODOS
1. Move to C++
 - New Design Method: Diagram, Prototype, Test, Implement, repeat
 - scrum? swift? agile?
 - look up design patterns
 - RESEARCH, EXPERIMENT
 - Ask about use of libraries X
    - refer back to https://www.youtube.com/watch?v=lS_qeBy3aQI, pezzzas work
 - rebuild the agents, make sure to research and implement good practices
  - design modularly
  - use overloading/default values
  - generalize classes so that I can put them together like lego in main, and then just run it
   - possibly make it so I can run multiple at once?
  - check SOLID principles
  - add docs
    - add tests
    - add comments
    - add a readme
 - make video about the process so far and next steps

2. Add Agent classes
 - Use agent as a super class
  - stores the get and set methods, name (since every agent needs an ID), score, position, and momentum.
 - use strategies and movement strategies as an intermediary abstract class
  - stores getter and setter methods for the strategy and movement strategy
 - add strategies and movement strategies as sublcasses of their respective abstract classes

 2.a Add strategies:
  - random, always picks random
  - defector, always picks defect
  - cooperator, always cooperates
  - tit-for-tat, picks the last move the opponent played
 2.b Add movement strategies:
  - random, always moves randomly
  - chaser, moves towards the opponent/collision point (TBD)
  - runner, moves away from the opponent/collision point (TBD)

3. Game
 - Create the hash system in C++
 - Look to improve, but its pretty solid
 - Mostly review that the hash stores the information I need

3. Simulation
 3.a. Collision
    - start with grid based collision
    - add substepping
    - add more from chatgpt if needed
    - use verlet
    - prioritize collision accuracy
 3.b. Allow for zoom
    - allow for much larger map generation
    - add panning
